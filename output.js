'use strict'
function ndarrayQuickSort0uint16(left,right,data,offset,s0,n0){
var sixth=((right-left+1)/6)|0,index1=left+sixth,index5=right-sixth,index3=(left+right)>>1,index2=index3-sixth,index4=index3+sixth,el1=index1,el2=index2,el3=index3,el4=index4,el5=index5,less=left+1,great=right-1,pivots_are_equal=true,tmp,tmp0,x,y,z,k,ptr0,ptr1,ptr2,comp_pivot1,comp_pivot2,comp,pivot1,pivot2
if(data[(offset+el1*s0)]>data[(offset+el2*s0)]){tmp0=el1;el1=el2;el2=tmp0}
if(data[(offset+el4*s0)]>data[(offset+el5*s0)]){tmp0=el4;el4=el5;el5=tmp0}
if(data[(offset+el1*s0)]>data[(offset+el3*s0)]){tmp0=el1;el1=el3;el3=tmp0}
if(data[(offset+el2*s0)]>data[(offset+el3*s0)]){tmp0=el2;el2=el3;el3=tmp0}
if(data[(offset+el1*s0)]>data[(offset+el4*s0)]){tmp0=el1;el1=el4;el4=tmp0}
if(data[(offset+el3*s0)]>data[(offset+el4*s0)]){tmp0=el3;el3=el4;el4=tmp0}
if(data[(offset+el2*s0)]>data[(offset+el5*s0)]){tmp0=el2;el2=el5;el5=tmp0}
if(data[(offset+el2*s0)]>data[(offset+el3*s0)]){tmp0=el2;el2=el3;el3=tmp0}
if(data[(offset+el4*s0)]>data[(offset+el5*s0)]){tmp0=el4;el4=el5;el5=tmp0}
pivot1=data[(offset+el2*s0)]
pivot2=data[(offset+el4*s0)]
pivots_are_equal=pivot1===pivot2
x=data[(offset+el1*s0)]
y=data[(offset+el3*s0)]
z=data[(offset+el5*s0)]
data[(offset+index1*s0)]=x
data[(offset+index3*s0)]=y
data[(offset+index5*s0)]=z
data[(offset+index2*s0)]=data[(offset+left*s0)]
data[(offset+index4*s0)]=data[(offset+right*s0)]
if(pivots_are_equal){
for(k=less;k<=great;++k){
comp=data[(offset+k*s0)]-pivot1
if(comp===0){continue}
if(comp<0){
if(k!==less){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
}
++less
}else{
while(true){
comp=data[(offset+great*s0)]-pivot1
if(comp>0){
great--
}else if(comp<0){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
ptr2=(offset+great*s0)
++less
--great
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=data[ptr2]
data[ptr2]=tmp
break
}else{
ptr0=(offset+k*s0)
ptr1=(offset+great*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
--great
break
}
}
}
}
}else{
for(k=less;k<=great;++k){
comp_pivot1=data[(offset+k*s0)]-pivot1
if(comp_pivot1<0){
if(k!==less){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
}
++less
}else{
comp_pivot2=data[(offset+k*s0)]-pivot2
if(comp_pivot2>0){
while(true){
comp=data[(offset+great*s0)]-pivot2
if(comp>0){
if(--great<k){break}
continue
}else{
comp=data[(offset+great*s0)]-pivot1
if(comp<0){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
ptr2=(offset+great*s0)
++less
--great
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=data[ptr2]
data[ptr2]=tmp
}else{
ptr0=(offset+k*s0)
ptr1=(offset+great*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
--great
}
break
}
}
}
}
}
}
data[(offset+left*s0)]=data[(offset+(less-1)*s0)]
data[(offset+(less-1)*s0)]=pivot1
data[(offset+right*s0)]=data[(offset+(great+1)*s0)]
data[(offset+(great+1)*s0)]=pivot2
if(((less-2)-left)<=32){
insertionSort(left,(less-2),data,offset,s0,n0)
}else{
ndarrayQuickSort0uint16(left,(less-2),data,offset,s0,n0)
}
if((right-(great+2))<=32){
insertionSort((great+2),right,data,offset,s0,n0)
}else{
ndarrayQuickSort0uint16((great+2),right,data,offset,s0,n0)
}
if(pivots_are_equal){
return
}
if(less<index1&&great>index5){
while(data[(offset+less*s0)]===pivot1){++less}
while(data[(offset+great*s0)]===pivot2){--great}
for(k=less;k<=great;++k){
comp_pivot1=data[(offset+k*s0)]-pivot1
if(comp_pivot1===0){
if(k!==less){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
}
++less
}else{
comp_pivot2=data[(offset+k*s0)]-pivot2
if(comp_pivot2===0){
while(true){
comp=data[(offset+great*s0)]-pivot2
if(comp===0){
if(--great<k){break}
continue
}else{
comp=data[(offset+great*s0)]-pivot1
if(comp<0){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
ptr2=(offset+great*s0)
++less
--great
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=data[ptr2]
data[ptr2]=tmp
}else{
ptr0=(offset+k*s0)
ptr1=(offset+great*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
--great
}
break
}
}
}
}
}
}
if((great-less)<=32){
insertionSort(less,great,data,offset,s0,n0)
}else{
ndarrayQuickSort0uint16(less,great,data,offset,s0,n0)
}
}return ndarrayQuickSort0uint16
'use strict'
function ndarrayQuickSort0float32(left,right,data,offset,s0,n0){
var sixth=((right-left+1)/6)|0,index1=left+sixth,index5=right-sixth,index3=(left+right)>>1,index2=index3-sixth,index4=index3+sixth,el1=index1,el2=index2,el3=index3,el4=index4,el5=index5,less=left+1,great=right-1,pivots_are_equal=true,tmp,tmp0,x,y,z,k,ptr0,ptr1,ptr2,comp_pivot1,comp_pivot2,comp,pivot1,pivot2
if(data[(offset+el1*s0)]>data[(offset+el2*s0)]){tmp0=el1;el1=el2;el2=tmp0}
if(data[(offset+el4*s0)]>data[(offset+el5*s0)]){tmp0=el4;el4=el5;el5=tmp0}
if(data[(offset+el1*s0)]>data[(offset+el3*s0)]){tmp0=el1;el1=el3;el3=tmp0}
if(data[(offset+el2*s0)]>data[(offset+el3*s0)]){tmp0=el2;el2=el3;el3=tmp0}
if(data[(offset+el1*s0)]>data[(offset+el4*s0)]){tmp0=el1;el1=el4;el4=tmp0}
if(data[(offset+el3*s0)]>data[(offset+el4*s0)]){tmp0=el3;el3=el4;el4=tmp0}
if(data[(offset+el2*s0)]>data[(offset+el5*s0)]){tmp0=el2;el2=el5;el5=tmp0}
if(data[(offset+el2*s0)]>data[(offset+el3*s0)]){tmp0=el2;el2=el3;el3=tmp0}
if(data[(offset+el4*s0)]>data[(offset+el5*s0)]){tmp0=el4;el4=el5;el5=tmp0}
pivot1=data[(offset+el2*s0)]
pivot2=data[(offset+el4*s0)]
pivots_are_equal=pivot1===pivot2
x=data[(offset+el1*s0)]
y=data[(offset+el3*s0)]
z=data[(offset+el5*s0)]
data[(offset+index1*s0)]=x
data[(offset+index3*s0)]=y
data[(offset+index5*s0)]=z
data[(offset+index2*s0)]=data[(offset+left*s0)]
data[(offset+index4*s0)]=data[(offset+right*s0)]
if(pivots_are_equal){
for(k=less;k<=great;++k){
comp=data[(offset+k*s0)]-pivot1
if(comp===0){continue}
if(comp<0){
if(k!==less){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
}
++less
}else{
while(true){
comp=data[(offset+great*s0)]-pivot1
if(comp>0){
great--
}else if(comp<0){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
ptr2=(offset+great*s0)
++less
--great
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=data[ptr2]
data[ptr2]=tmp
break
}else{
ptr0=(offset+k*s0)
ptr1=(offset+great*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
--great
break
}
}
}
}
}else{
for(k=less;k<=great;++k){
comp_pivot1=data[(offset+k*s0)]-pivot1
if(comp_pivot1<0){
if(k!==less){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
}
++less
}else{
comp_pivot2=data[(offset+k*s0)]-pivot2
if(comp_pivot2>0){
while(true){
comp=data[(offset+great*s0)]-pivot2
if(comp>0){
if(--great<k){break}
continue
}else{
comp=data[(offset+great*s0)]-pivot1
if(comp<0){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
ptr2=(offset+great*s0)
++less
--great
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=data[ptr2]
data[ptr2]=tmp
}else{
ptr0=(offset+k*s0)
ptr1=(offset+great*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
--great
}
break
}
}
}
}
}
}
data[(offset+left*s0)]=data[(offset+(less-1)*s0)]
data[(offset+(less-1)*s0)]=pivot1
data[(offset+right*s0)]=data[(offset+(great+1)*s0)]
data[(offset+(great+1)*s0)]=pivot2
if(((less-2)-left)<=32){
insertionSort(left,(less-2),data,offset,s0,n0)
}else{
ndarrayQuickSort0float32(left,(less-2),data,offset,s0,n0)
}
if((right-(great+2))<=32){
insertionSort((great+2),right,data,offset,s0,n0)
}else{
ndarrayQuickSort0float32((great+2),right,data,offset,s0,n0)
}
if(pivots_are_equal){
return
}
if(less<index1&&great>index5){
while(data[(offset+less*s0)]===pivot1){++less}
while(data[(offset+great*s0)]===pivot2){--great}
for(k=less;k<=great;++k){
comp_pivot1=data[(offset+k*s0)]-pivot1
if(comp_pivot1===0){
if(k!==less){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
}
++less
}else{
comp_pivot2=data[(offset+k*s0)]-pivot2
if(comp_pivot2===0){
while(true){
comp=data[(offset+great*s0)]-pivot2
if(comp===0){
if(--great<k){break}
continue
}else{
comp=data[(offset+great*s0)]-pivot1
if(comp<0){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
ptr2=(offset+great*s0)
++less
--great
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=data[ptr2]
data[ptr2]=tmp
}else{
ptr0=(offset+k*s0)
ptr1=(offset+great*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
--great
}
break
}
}
}
}
}
}
if((great-less)<=32){
insertionSort(less,great,data,offset,s0,n0)
}else{
ndarrayQuickSort0float32(less,great,data,offset,s0,n0)
}
}return ndarrayQuickSort0float32
'use strict'
function ndarrayQuickSort0int32(left,right,data,offset,s0,n0){
var sixth=((right-left+1)/6)|0,index1=left+sixth,index5=right-sixth,index3=(left+right)>>1,index2=index3-sixth,index4=index3+sixth,el1=index1,el2=index2,el3=index3,el4=index4,el5=index5,less=left+1,great=right-1,pivots_are_equal=true,tmp,tmp0,x,y,z,k,ptr0,ptr1,ptr2,comp_pivot1,comp_pivot2,comp,pivot1,pivot2
if(data[(offset+el1*s0)]>data[(offset+el2*s0)]){tmp0=el1;el1=el2;el2=tmp0}
if(data[(offset+el4*s0)]>data[(offset+el5*s0)]){tmp0=el4;el4=el5;el5=tmp0}
if(data[(offset+el1*s0)]>data[(offset+el3*s0)]){tmp0=el1;el1=el3;el3=tmp0}
if(data[(offset+el2*s0)]>data[(offset+el3*s0)]){tmp0=el2;el2=el3;el3=tmp0}
if(data[(offset+el1*s0)]>data[(offset+el4*s0)]){tmp0=el1;el1=el4;el4=tmp0}
if(data[(offset+el3*s0)]>data[(offset+el4*s0)]){tmp0=el3;el3=el4;el4=tmp0}
if(data[(offset+el2*s0)]>data[(offset+el5*s0)]){tmp0=el2;el2=el5;el5=tmp0}
if(data[(offset+el2*s0)]>data[(offset+el3*s0)]){tmp0=el2;el2=el3;el3=tmp0}
if(data[(offset+el4*s0)]>data[(offset+el5*s0)]){tmp0=el4;el4=el5;el5=tmp0}
pivot1=data[(offset+el2*s0)]
pivot2=data[(offset+el4*s0)]
pivots_are_equal=pivot1===pivot2
x=data[(offset+el1*s0)]
y=data[(offset+el3*s0)]
z=data[(offset+el5*s0)]
data[(offset+index1*s0)]=x
data[(offset+index3*s0)]=y
data[(offset+index5*s0)]=z
data[(offset+index2*s0)]=data[(offset+left*s0)]
data[(offset+index4*s0)]=data[(offset+right*s0)]
if(pivots_are_equal){
for(k=less;k<=great;++k){
comp=data[(offset+k*s0)]-pivot1
if(comp===0){continue}
if(comp<0){
if(k!==less){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
}
++less
}else{
while(true){
comp=data[(offset+great*s0)]-pivot1
if(comp>0){
great--
}else if(comp<0){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
ptr2=(offset+great*s0)
++less
--great
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=data[ptr2]
data[ptr2]=tmp
break
}else{
ptr0=(offset+k*s0)
ptr1=(offset+great*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
--great
break
}
}
}
}
}else{
for(k=less;k<=great;++k){
comp_pivot1=data[(offset+k*s0)]-pivot1
if(comp_pivot1<0){
if(k!==less){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
}
++less
}else{
comp_pivot2=data[(offset+k*s0)]-pivot2
if(comp_pivot2>0){
while(true){
comp=data[(offset+great*s0)]-pivot2
if(comp>0){
if(--great<k){break}
continue
}else{
comp=data[(offset+great*s0)]-pivot1
if(comp<0){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
ptr2=(offset+great*s0)
++less
--great
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=data[ptr2]
data[ptr2]=tmp
}else{
ptr0=(offset+k*s0)
ptr1=(offset+great*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
--great
}
break
}
}
}
}
}
}
data[(offset+left*s0)]=data[(offset+(less-1)*s0)]
data[(offset+(less-1)*s0)]=pivot1
data[(offset+right*s0)]=data[(offset+(great+1)*s0)]
data[(offset+(great+1)*s0)]=pivot2
if(((less-2)-left)<=32){
insertionSort(left,(less-2),data,offset,s0,n0)
}else{
ndarrayQuickSort0int32(left,(less-2),data,offset,s0,n0)
}
if((right-(great+2))<=32){
insertionSort((great+2),right,data,offset,s0,n0)
}else{
ndarrayQuickSort0int32((great+2),right,data,offset,s0,n0)
}
if(pivots_are_equal){
return
}
if(less<index1&&great>index5){
while(data[(offset+less*s0)]===pivot1){++less}
while(data[(offset+great*s0)]===pivot2){--great}
for(k=less;k<=great;++k){
comp_pivot1=data[(offset+k*s0)]-pivot1
if(comp_pivot1===0){
if(k!==less){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
}
++less
}else{
comp_pivot2=data[(offset+k*s0)]-pivot2
if(comp_pivot2===0){
while(true){
comp=data[(offset+great*s0)]-pivot2
if(comp===0){
if(--great<k){break}
continue
}else{
comp=data[(offset+great*s0)]-pivot1
if(comp<0){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
ptr2=(offset+great*s0)
++less
--great
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=data[ptr2]
data[ptr2]=tmp
}else{
ptr0=(offset+k*s0)
ptr1=(offset+great*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
--great
}
break
}
}
}
}
}
}
if((great-less)<=32){
insertionSort(less,great,data,offset,s0,n0)
}else{
ndarrayQuickSort0int32(less,great,data,offset,s0,n0)
}
}return ndarrayQuickSort0int32
'use strict'
function ndarrayQuickSort0array(left,right,data,offset,s0,n0){
var sixth=((right-left+1)/6)|0,index1=left+sixth,index5=right-sixth,index3=(left+right)>>1,index2=index3-sixth,index4=index3+sixth,el1=index1,el2=index2,el3=index3,el4=index4,el5=index5,less=left+1,great=right-1,pivots_are_equal=true,tmp,tmp0,x,y,z,k,ptr0,ptr1,ptr2,comp_pivot1,comp_pivot2,comp,pivot1,pivot2
if(data[(offset+el1*s0)]>data[(offset+el2*s0)]){tmp0=el1;el1=el2;el2=tmp0}
if(data[(offset+el4*s0)]>data[(offset+el5*s0)]){tmp0=el4;el4=el5;el5=tmp0}
if(data[(offset+el1*s0)]>data[(offset+el3*s0)]){tmp0=el1;el1=el3;el3=tmp0}
if(data[(offset+el2*s0)]>data[(offset+el3*s0)]){tmp0=el2;el2=el3;el3=tmp0}
if(data[(offset+el1*s0)]>data[(offset+el4*s0)]){tmp0=el1;el1=el4;el4=tmp0}
if(data[(offset+el3*s0)]>data[(offset+el4*s0)]){tmp0=el3;el3=el4;el4=tmp0}
if(data[(offset+el2*s0)]>data[(offset+el5*s0)]){tmp0=el2;el2=el5;el5=tmp0}
if(data[(offset+el2*s0)]>data[(offset+el3*s0)]){tmp0=el2;el2=el3;el3=tmp0}
if(data[(offset+el4*s0)]>data[(offset+el5*s0)]){tmp0=el4;el4=el5;el5=tmp0}
pivot1=data[(offset+el2*s0)]
pivot2=data[(offset+el4*s0)]
pivots_are_equal=pivot1===pivot2
x=data[(offset+el1*s0)]
y=data[(offset+el3*s0)]
z=data[(offset+el5*s0)]
data[(offset+index1*s0)]=x
data[(offset+index3*s0)]=y
data[(offset+index5*s0)]=z
data[(offset+index2*s0)]=data[(offset+left*s0)]
data[(offset+index4*s0)]=data[(offset+right*s0)]
if(pivots_are_equal){
for(k=less;k<=great;++k){
comp=data[(offset+k*s0)]-pivot1
if(comp===0){continue}
if(comp<0){
if(k!==less){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
}
++less
}else{
while(true){
comp=data[(offset+great*s0)]-pivot1
if(comp>0){
great--
}else if(comp<0){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
ptr2=(offset+great*s0)
++less
--great
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=data[ptr2]
data[ptr2]=tmp
break
}else{
ptr0=(offset+k*s0)
ptr1=(offset+great*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
--great
break
}
}
}
}
}else{
for(k=less;k<=great;++k){
comp_pivot1=data[(offset+k*s0)]-pivot1
if(comp_pivot1<0){
if(k!==less){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
}
++less
}else{
comp_pivot2=data[(offset+k*s0)]-pivot2
if(comp_pivot2>0){
while(true){
comp=data[(offset+great*s0)]-pivot2
if(comp>0){
if(--great<k){break}
continue
}else{
comp=data[(offset+great*s0)]-pivot1
if(comp<0){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
ptr2=(offset+great*s0)
++less
--great
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=data[ptr2]
data[ptr2]=tmp
}else{
ptr0=(offset+k*s0)
ptr1=(offset+great*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
--great
}
break
}
}
}
}
}
}
data[(offset+left*s0)]=data[(offset+(less-1)*s0)]
data[(offset+(less-1)*s0)]=pivot1
data[(offset+right*s0)]=data[(offset+(great+1)*s0)]
data[(offset+(great+1)*s0)]=pivot2
if(((less-2)-left)<=32){
insertionSort(left,(less-2),data,offset,s0,n0)
}else{
ndarrayQuickSort0array(left,(less-2),data,offset,s0,n0)
}
if((right-(great+2))<=32){
insertionSort((great+2),right,data,offset,s0,n0)
}else{
ndarrayQuickSort0array((great+2),right,data,offset,s0,n0)
}
if(pivots_are_equal){
return
}
if(less<index1&&great>index5){
while(data[(offset+less*s0)]===pivot1){++less}
while(data[(offset+great*s0)]===pivot2){--great}
for(k=less;k<=great;++k){
comp_pivot1=data[(offset+k*s0)]-pivot1
if(comp_pivot1===0){
if(k!==less){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
}
++less
}else{
comp_pivot2=data[(offset+k*s0)]-pivot2
if(comp_pivot2===0){
while(true){
comp=data[(offset+great*s0)]-pivot2
if(comp===0){
if(--great<k){break}
continue
}else{
comp=data[(offset+great*s0)]-pivot1
if(comp<0){
ptr0=(offset+k*s0)
ptr1=(offset+less*s0)
ptr2=(offset+great*s0)
++less
--great
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=data[ptr2]
data[ptr2]=tmp
}else{
ptr0=(offset+k*s0)
ptr1=(offset+great*s0)
tmp=data[ptr0]
data[ptr0]=data[ptr1]
data[ptr1]=tmp
--great
}
break
}
}
}
}
}
}
if((great-less)<=32){
insertionSort(less,great,data,offset,s0,n0)
}else{
ndarrayQuickSort0array(less,great,data,offset,s0,n0)
}
}return ndarrayQuickSort0array
TAP version 13
# ndarray-sort-1d
not ok 1 Error: ndarray-sort: Generic ndarrays not yet supported
  ---
    operator: error
    expected: 
    actual:   {}
    stack:
      Error: ndarray-sort: Generic ndarrays not yet supported
        at compileSort (/Users/mikolalysenko/GitHub/ndarray-sort/lib/compile_sort.js:553:11)
        at sort (/Users/mikolalysenko/GitHub/ndarray-sort/sort.js:13:34)
        at runTest (/Users/mikolalysenko/GitHub/ndarray-sort/test/test.js:44:5)
        at Test._cb (/Users/mikolalysenko/GitHub/ndarray-sort/test/test.js:56:3)
        at Test.run (/Users/mikolalysenko/GitHub/ndarray-sort/node_modules/tape/lib/test.js:52:14)
        at Object.next [as _onImmediate] (/Users/mikolalysenko/GitHub/ndarray-sort/node_modules/tape/lib/results.js:25:11)
        at processImmediate [as _immediateCallback] (timers.js:330:15)
  ...

1..1
# tests 1
# pass  0
# fail  1
